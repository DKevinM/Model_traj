<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Leaflet Particle Smoke — JS-only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100%; }
    .control-bar { position: absolute; top: 10px; left: 10px; z-index: 1000; background: rgba(255,255,255,0.9); padding: 8px 10px; border-radius: 8px; font-family: system-ui, Arial, sans-serif; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .control-bar label { margin-right: 6px; }
    .control-row { display: flex; gap: 8px; align-items: center; margin: 4px 0; flex-wrap: wrap; }
    .btn { border: 1px solid #ccc; padding: 4px 10px; border-radius: 6px; background: #f7f7f7; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .stat { margin-left: 8px; opacity: 0.8; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="control-bar">
    <div class="control-row">
      <button id="start" class="btn">Start</button>
      <button id="stop" class="btn">Stop</button>
      <label>Speed× <input id="speed" type="range" min="0.2" max="5" step="0.1" value="1"></label>
      <label>Particles <input id="count" type="range" min="200" max="8000" step="200" value="2000"></label>
    </div>
    <div class="control-row">
      <label>Tail (frames) <input id="trail" type="range" min="0" max="20" step="1" value="6"></label>
      <label>API wind <input id="useApi" type="checkbox" checked></label>
      <span class="stat" id="windStat">wind: —</span>
      <span class="stat" id="fps">fps: —</span>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ====== Map setup ======
  const map = L.map('map', { preferCanvas: true }).setView([53.5461, -113.4938], 9);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // Draggable source marker (emission origin)
  const source = L.marker([53.5461, -113.4938], { draggable: true }).addTo(map)
                 .bindTooltip('Emission source', {permanent:true, direction:'top', offset:[0,-18]});

  // ====== Canvas overlay for particles ======
  const overlayPane = map.getPanes().overlayPane;
  const canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0; canvas.style.left = 0;
  overlayPane.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    const size = map.getSize();
    canvas.width = size.x; canvas.height = size.y;
    const pos = map._getMapPanePos();
    L.DomUtil.setPosition(canvas, pos.multiplyBy(-1));
  }
  map.on('resize zoom move', resizeCanvas);
  resizeCanvas();

  // Keep canvas aligned with map when it pans (leaflet moves the overlayPane)
  const originalSetPos = L.DomUtil.setPosition;
  L.DomUtil.setPosition = function(el, point) {
    originalSetPos(el, point);
    if (el === map.getPanes().mapPane) {
      const pos = map._getMapPanePos();
      L.DomUtil.setPosition(canvas, pos.multiplyBy(-1));
    }
  };

  // ====== Parameters ======
  const R = 6371000; // m
  const toDeg = 180/Math.PI;
  let speedFactor = 1.0;           // user slider multiplier
  let targetCount = 2000;          // user slider particle count
  let maxTrail = 6;                // drawn tail length
  let running = false;

  // ====== Wind field ======
  // We maintain a simple, uniform wind from an API (Open-Meteo) near the source.
  // You can replace this with a gridded field + bilinear interpolation for higher realism.
  let wind = { u: 4.0, v: 0.5, speed: Math.hypot(4.0,0.5), dir: 270 }; // default westerly

  async function refreshWindFromAPI(){
    try {
      const ll = source.getLatLng();
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${ll.lat.toFixed(4)}&longitude=${ll.lng.toFixed(4)}&hourly=wind_speed_10m,wind_direction_10m&forecast_days=1`;
      const r = await fetch(url);
      const j = await r.json();
      const i = 0; // take the first hour for demo
      const spd = j.hourly.wind_speed_10m[i]; // m/s
      const dir = j.hourly.wind_direction_10m[i]; // deg FROM which the wind blows
      const rad = dir * Math.PI/180;
      // Convert met dir -> u (east), v (north). Meteorological is FROM dir.
      const u = -spd * Math.sin(rad);
      const v = -spd * Math.cos(rad);
      wind = { u, v, speed: spd, dir };
      windStat.textContent = `wind: ${spd.toFixed(1)} m/s from ${dir.toFixed(0)}°`;
    } catch (e){
      console.warn('Wind API failed, using default', e);
      windStat.textContent = `wind: default ${wind.speed.toFixed(1)} m/s`;
    }
  }

  // ====== Particles ======
  const particles = [];
  const maxAge = 18; // seconds each particle lives (visual smoke feel)

  function spawn(n){
    const ll = source.getLatLng();
    for (let i=0;i<n;i++){
      // Small random offset near source (~300 m)
      const r = 0.003 * Math.random();
      const th = Math.random()*Math.PI*2;
      const dlat = r * Math.sin(th);
      const dlon = r * Math.cos(th);
      particles.push({ lat: ll.lat + dlat, lon: ll.lng + dlon, age: 0, trail: [] });
    }
  }

  function ensureParticleCount(){
    if (particles.length < targetCount) spawn(targetCount - particles.length);
    if (particles.length > targetCount) particles.splice(targetCount);
  }

  function step(dt){
    // Simple Euler advection with uniform wind
    const u = wind.u * speedFactor; // m/s east
    const v = wind.v * speedFactor; // m/s north

    for (let p of particles){
      // Save trail
      if (maxTrail>0) {
        p.trail.push([p.lat, p.lon]);
        if (p.trail.length > maxTrail) p.trail.shift();
      }

      const coslat = Math.cos(p.lat * Math.PI/180);
      const dlat = (v / R) * toDeg * dt;
      const dlon = (u / (R * Math.max(1e-6, coslat))) * toDeg * dt;
      p.lat += dlat;
      p.lon += dlon;
      p.age += dt;

      // Cull or respawn if too old or far out of view
      if (p.age > maxAge) {
        const ll = source.getLatLng();
        p.lat = ll.lat; p.lon = ll.lng; p.age = 0; p.trail.length = 0;
      }
    }
  }

  function draw(){
    const size = map.getSize();
    ctx.clearRect(0,0, size.x, size.y);

    // Slight fade for motion blur (optional):
    // ctx.fillStyle = 'rgba(255,255,255,0.08)';
    // ctx.fillRect(0,0, size.x, size.y);

    ctx.lineWidth = 1;

    for (let p of particles){
      // Draw trail first
      if (p.trail.length > 1){
        ctx.beginPath();
        const pt0 = map.latLngToLayerPoint(p.trail[0]);
        ctx.moveTo(pt0.x, pt0.y);
        for (let i=1;i<p.trail.length;i++){
          const pti = map.latLngToLayerPoint(p.trail[i]);
          ctx.lineTo(pti.x, pti.y);
        }
        ctx.strokeStyle = 'rgba(80,80,80,0.35)';
        ctx.stroke();
      }

      // Draw head
      const pt = map.latLngToLayerPoint([p.lat, p.lon]);
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 1.6, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(30,30,30,0.8)';
      ctx.fill();
    }
  }

  // ====== Animation loop ======
  let last = performance.now();
  let frames = 0, fpsAccum = 0;
  function animate(){
    if (!running){ requestAnimationFrame(animate); return; }
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000); // cap large jumps at 50 ms
    last = now;

    ensureParticleCount();
    step(dt);
    draw();

    // FPS stat
    frames++; fpsAccum += dt;
    if (fpsAccum >= 0.5){
      fps.textContent = `fps: ${(frames/fpsAccum).toFixed(0)}`;
      frames = 0; fpsAccum = 0;
    }
    requestAnimationFrame(animate);
  }

  // ====== UI wiring ======
  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const speedEl  = document.getElementById('speed');
  const countEl  = document.getElementById('count');
  const trailEl  = document.getElementById('trail');
  const useApiEl = document.getElementById('useApi');
  const windStat = document.getElementById('windStat');
  const fps      = document.getElementById('fps');

  startBtn.onclick = async () => {
    running = true;
    last = performance.now();
    if (useApiEl.checked) await refreshWindFromAPI();
  };
  stopBtn.onclick = () => { running = false; };
  speedEl.oninput = () => { speedFactor = parseFloat(speedEl.value); };
  countEl.oninput = () => { targetCount = parseInt(countEl.value, 10); };
  trailEl.oninput = () => { maxTrail = parseInt(trailEl.value, 10); };
  useApiEl.onchange = async () => { if (useApiEl.checked) await refreshWindFromAPI(); };

  // Refresh wind when source is moved
  source.on('moveend', async () => { if (useApiEl.checked) await refreshWindFromAPI(); });

  // Start with a seed batch
  spawn(targetCount);
  requestAnimationFrame(animate);
  </script>
</body>
</html>
