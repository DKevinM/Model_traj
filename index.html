<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Leaflet Particle Smoke — Live Wind + Gaussian (Stable)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100%; }
    .control-bar { position:absolute; top:10px; left:10px; z-index:1000; background:rgba(255,255,255,.95); padding:10px 12px; border-radius:10px; font:14px system-ui, Arial; box-shadow:0 2px 10px rgba(0,0,0,.15); max-width:780px; }
    .control-row { display:flex; gap:12px; align-items:center; margin:6px 0; flex-wrap:wrap; }
    .btn { border:1px solid #ccc; padding:4px 10px; border-radius:6px; background:#f7f7f7; cursor:pointer; }
    input[type=range]{ width:180px; }
    .stat{ opacity:.85; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="control-bar">
    <div class="control-row">
      <button id="start" class="btn">Start</button>
      <button id="stop"  class="btn">Stop</button>
      <span class="stat" id="fps">fps: —</span>
    </div>
    <div class="control-row">
      <strong>Source</strong>
      <label>Radius (m) <input id="radius" type="range" min="10" max="3000" step="10" value="200"></label>
      <label>Spawn (p/s) <input id="spawn" type="range" min="10" max="4000" step="10" value="600"></label>
      <label>Max p <input id="maxp" type="range" min="200" max="25000" step="200" value="8000"></label>
      <span class="stat">Click map to move centre</span>
    </div>
    <div class="control-row">
      <strong>Wind</strong>
      <label><input id="manualWind" type="checkbox" checked> Manual</label>
      <label>Speed (m/s) <input id="windSpeed" type="range" min="0" max="40" step="0.1" value="6"></label>
      <label>Dir (° from) <input id="windDir" type="range" min="0" max="360" step="1" value="270"></label>
      <label><input id="autoWind" type="checkbox"> Auto (Open‑Meteo)</label>
      <label>Refresh (min) <input id="windEvery" type="range" min="2" max="60" step="1" value="10"></label>
      <button id="windNow" class="btn">Refresh now</button>
      <span class="stat" id="windStat">wind: —</span>
    </div>
    <div class="control-row">
      <strong>Dispersion</strong>
      <label>K (m²/s) <input id="K" type="range" min="0" max="200" step="1" value="30"></label>
      <label>Tail len <input id="trail" type="range" min="0" max="120" step="1" value="12"></label>
      <label>Tail fade <input id="tailFade" type="range" min="0" max="1" step="0.05" value="0.35"></label>
      <label>Max age (s) <input id="maxAge" type="range" min="4" max="120" step="1" value="30"></label>
      <label><input id="gaussPuff" type="checkbox"> Puff bursts</label>
      <label>Bursts/sec <input id="puffRate" type="range" min="0" max="5" step="0.1" value="0"></label>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
  <script defer>
  window.addEventListener('DOMContentLoaded', () => {
    // ===== Constants & state =====
    const R = 6371000, toDeg = 180/Math.PI;
    let running = false;

    // Source
    let sourceRadiusM = 200, spawnPerSec = 600, spawnAcc = 0, maxParticles = 8000;

    // Trails/aging
    let maxTrail = 12, tailFade = 0.35, maxLifesec = 30;

    // Wind
    let manual = true, manualSpeed = 6.0, manualDir = 270;
    let autoWind = false, autoWindEveryMin = 10, autoTimer = null;
    let wind = {u:0,v:0,speed:0,dir:0};

    // Diffusion
    let K = 30; // m^2/s

    // Puffs
    let gaussMode = false, puffRate = 0; // per sec

    // Particles
    const particles = [];

    // ===== Map (no double init) =====
    const map = L.map('map', { preferCanvas:true });
    map.setView([53.5461, -113.4938], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);

    let sourceCenter = L.latLng(53.5461, -113.4938);
    const marker = L.marker(sourceCenter, {draggable:true}).addTo(map)
      .bindTooltip('Source', {permanent:true, direction:'top', offset:[0,-18]});
    marker.on('move', e => { sourceCenter = e.latlng; circle.setLatLng(sourceCenter); if (autoWind) refreshWindFromAPI(); });
    const circle = L.circle(sourceCenter, { radius: sourceRadiusM, color:'#2b6cb0', weight:1.5, fillOpacity:0.05 }).addTo(map);
    map.on('click', e => { sourceCenter = e.latlng; marker.setLatLng(sourceCenter); circle.setLatLng(sourceCenter); if (autoWind) refreshWindFromAPI(); });

    // ===== Canvas overlay =====
    const canvas = document.createElement('canvas');
    canvas.style.position='absolute'; canvas.style.top=0; canvas.style.left=0;
    map.getPanes().overlayPane.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const s = map.getSize();
      canvas.width = s.x; canvas.height = s.y;
      const pos = map._getMapPanePos();
      L.DomUtil.setPosition(canvas, pos.multiplyBy(-1));
      if (particles.length) draw();
    }
    map.on('resize zoom move', resizeCanvas);
    resizeCanvas();

    // ===== UI wiring =====
    const fpsEl = document.getElementById('fps');
    const windStat = document.getElementById('windStat');

    // Source
    document.getElementById('radius').oninput = e => { sourceRadiusM = +e.target.value; circle.setRadius(sourceRadiusM); };
    document.getElementById('spawn').oninput  = e => { spawnPerSec   = +e.target.value; };
    document.getElementById('maxp').oninput   = e => { maxParticles  = +e.target.value; };

    // Wind
    const manualEl = document.getElementById('manualWind');
    const wsEl = document.getElementById('windSpeed');
    const wdEl = document.getElementById('windDir');
    const autoEl = document.getElementById('autoWind');
    const everyEl = document.getElementById('windEvery');
    const windNow = document.getElementById('windNow');

    manualEl.onchange = () => { manual = manualEl.checked; if (manual) updateManualWind(); };
    wsEl.oninput = () => { manualSpeed = +wsEl.value; if (manual) updateManualWind(); };
    wdEl.oninput = () => { manualDir   = +wdEl.value; if (manual) updateManualWind(); };

    autoEl.onchange = () => { autoWind = autoEl.checked; setupAutoWind(); };
    everyEl.oninput = () => { autoWindEveryMin = +everyEl.value; setupAutoWind(); };
    windNow.onclick = () => refreshWindFromAPI();

    function setupAutoWind(){
      if (autoTimer){ clearInterval(autoTimer); autoTimer = null; }
      if (autoWind){
        manual = false; manualEl.checked = false;
        refreshWindFromAPI();
        autoTimer = setInterval(refreshWindFromAPI, Math.max(2, autoWindEveryMin)*60*1000);
      }
    }

    function updateManualWind(){
      const rad = manualDir*Math.PI/180;
      wind = { u: -manualSpeed*Math.sin(rad), v: -manualSpeed*Math.cos(rad), speed: manualSpeed, dir: manualDir };
      windStat.textContent = `wind: ${manualSpeed.toFixed(1)} m/s from ${manualDir.toFixed(0)}° (manual)`;
    }

    async function refreshWindFromAPI(){
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${sourceCenter.lat.toFixed(4)}&longitude=${sourceCenter.lng.toFixed(4)}&hourly=wind_speed_10m,wind_direction_10m&forecast_days=1`;
        const r = await fetch(url);
        const j = await r.json();
        const i = 0;
        const spd = j?.hourly?.wind_speed_10m?.[i];
        const dir = j?.hourly?.wind_direction_10m?.[i];
        if (spd==null || dir==null) throw new Error('API missing fields');
        const rad = dir*Math.PI/180;
        wind = { u: -spd*Math.sin(rad), v: -spd*Math.cos(rad), speed: spd, dir };
        windStat.textContent = `wind: ${spd.toFixed(1)} m/s from ${dir.toFixed(0)}° (API)`;
      } catch(e){
        windStat.textContent = 'wind: API failed; keeping previous';
        console.warn('Open‑Meteo fetch failed', e);
      }
    }

    // Dispersion
    document.getElementById('K').oninput = e => { K = +e.target.value; };
    document.getElementById('trail').oninput = e => { maxTrail = +e.target.value; };
    document.getElementById('tailFade').oninput = e => { tailFade = +e.target.value; };
    document.getElementById('maxAge').oninput = e => { maxLifesec = +e.target.value; };
    const gaussEl = document.getElementById('gaussPuff');
    const puffEl  = document.getElementById('puffRate');
    gaussEl.onchange = () => { gaussMode = gaussEl.checked; };
    puffEl.oninput   = () => { puffRate  = +puffEl.value; };

    // Buttons
    document.getElementById('start').onclick = () => { running = true; last = performance.now(); };
    document.getElementById('stop').onclick  = () => { running = false; };

    // ===== Emission helpers =====
    function jitterDiskMeters(centerLL, radiusM){
      const r = radiusM*Math.sqrt(Math.random());
      const th = Math.random()*Math.PI*2;
      const dy = r*Math.sin(th), dx = r*Math.cos(th);
      const dlat = (dy/R)*toDeg;
      const dlon = (dx/(R*Math.max(1e-6, Math.cos(centerLL.lat*Math.PI/180))))*toDeg;
      return L.latLng(centerLL.lat + dlat, centerLL.lng + dlon);
    }

    function spawn(dt){
      spawnAcc += spawnPerSec*dt;
      let make = Math.floor(spawnAcc);
      spawnAcc -= make;
      make = Math.min(make, Math.max(0, maxParticles - particles.length));
      for (let i=0;i<make;i++){
        const ll = jitterDiskMeters(sourceCenter, sourceRadiusM);
        particles.push({ lat: ll.lat, lon: ll.lng, age: 0, trail: [], puff:false });
      }
      if (gaussMode && puffRate>0){
        const expected = puffRate*dt;
        if (Math.random() < expected){
          const ll0 = jitterDiskMeters(sourceCenter, Math.max(5, 0.2*sourceRadiusM));
          const puffN = Math.min(200, Math.max(20, Math.round(spawnPerSec*0.2)));
          for (let i=0;i<puffN && particles.length<maxParticles;i++){
            const ll = jitterDiskMeters(ll0, Math.max(5, sourceRadiusM*0.1));
            particles.push({ lat: ll.lat, lon: ll.lng, age: 0, trail: [], puff:true });
          }
        }
      }
    }

    // ===== Physics =====
    function step(dt){
      if (manual && !autoWind) updateManualWind();
      spawn(dt);
      const u = wind.u, v = wind.v;
      const sig = Math.sqrt(Math.max(0, 2*K*dt));

      for (let p of particles){
        if (maxTrail>0){
          p.trail.push([p.lat, p.lon]);
          if (p.trail.length>maxTrail) p.trail.shift();
        }
        const coslat = Math.cos(p.lat*Math.PI/180);
        p.lat += (v/R)*toDeg*dt;
        p.lon += (u/(R*Math.max(1e-6,coslat)))*toDeg*dt;
        if (sig>0){
          const th = Math.random()*2*Math.PI;
          const dy = sig*Math.sin(th), dx = sig*Math.cos(th);
          p.lat += (dy/R)*toDeg;
          p.lon += (dx/(R*Math.max(1e-6, Math.cos(p.lat*Math.PI/180))))*toDeg;
        }
        p.age += dt;
        if (p.age > maxLifesec){
          const ll = jitterDiskMeters(sourceCenter, sourceRadiusM);
          p.lat = ll.lat; p.lon = ll.lng; p.age = 0; p.trail.length = 0; p.puff=false;
        }
      }
    }

    // ===== Draw =====
    function draw(){
      const s = map.getSize();
      ctx.clearRect(0,0,s.x,s.y);
      ctx.lineWidth = 1;
      for (let p of particles){
        if (p.trail.length>1){
          ctx.beginPath();
          const pt0 = map.latLngToLayerPoint(p.trail[0]); ctx.moveTo(pt0.x, pt0.y);
          for (let i=1;i<p.trail.length;i++){
            const pti = map.latLngToLayerPoint(p.trail[i]); ctx.lineTo(pti.x, pti.y);
          }
          ctx.strokeStyle = `rgba(80,80,80,${tailFade})`;
          ctx.stroke();
        }
        const pt = map.latLngToLayerPoint([p.lat, p.lon]);
        ctx.beginPath(); ctx.arc(pt.x, pt.y, 1.6, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(30,30,30,0.85)'; ctx.fill();
      }
    }

    // ===== Animation =====
    let last = performance.now(), frames=0, acc=0;
    function animate(){
      const now = performance.now();
      const dt = Math.min(0.05, (now-last)/1000);
      last = now;
      if (running){ step(dt); draw(); frames++; acc += dt; if (acc>=0.5){ fpsEl.textContent = `fps: ${(frames/acc).toFixed(0)}`; frames=0; acc=0; } }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ===== Seed and autostart =====
    for (let i=0;i<1200;i++){ const ll = jitterDiskMeters(sourceCenter, sourceRadiusM); particles.push({lat: ll.lat, lon: ll.lng, age: Math.random()*maxLifesec*0.7, trail: []}); }
    updateManualWind();
    draw();
    running = true;

  });
  </script>
</body>
</html>
